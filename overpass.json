const express = require('express');
const axios = require('axios');
const csv = require('csv-parser');
const schedule = require('node-schedule');
const { parse } = require('url');
const osmtogeojson = require('osmtogeojson');
const fs = require('fs');

const app = express();
const port = 3000;

let cachedGeoJSON = {
  type: "FeatureCollection",
  features: []
};

// Function to fetch and parse CSV data
async function fetchCSVData() {
  const url = 'https://pota.app/all_parks_ext.csv';
  const response = await axios.get(url);
  const data = response.data;
  const results = [];

  return new Promise((resolve, reject) => {
    require('stream').Readable.from(data)
      .pipe(csv())
      .on('data', (row) => {
        results.push(row);
      })
      .on('end', () => {
        resolve(results);
      })
      .on('error', reject);
  });
}

// Function to convert CSV data to GeoJSON
function convertCSVToGeoJSON(csvData) {
  return {
    type: "FeatureCollection",
    features: csvData.map(row => ({
      type: "Feature",
      properties: {
        reference: row.reference,
        name: row.name,
        active: row.active,
        entityId: row.entityId,
        locationDesc: row.locationDesc,
        grid: row.grid
      },
      geometry: {
        type: "Point",
        coordinates: [parseFloat(row.longitude), parseFloat(row.latitude)]
      }
    }))
  };
}

// Function to fetch Overpass API data
async function fetchOverpassData() {
  const query = `
    [out:json];
    nwr["communication:amateur_radio:pota"];
    out geom;
  `;
  const url = `https://overpass-api.de/api/interpreter?data=${encodeURIComponent(query)}`;
  const response = await axios.get(url);
  return response.data;
}

// Function to convert Overpass data to GeoJSON using osmtogeojson
function convertOverpassToGeoJSON(overpassData) {
  if (!overpassData || !overpassData.elements) {
    throw new Error('Invalid Overpass data');
  }

  const geojson = osmtogeojson(overpassData);
  geojson.features.forEach(feature => {
    if (feature.properties["communication:amateur_radio:pota"]) {
      feature.properties.feature = feature.properties["communication:amateur_radio:pota"];
      feature.properties.reference = feature.properties["communication:amateur_radio:pota"];
    }
  });
  return geojson;
}

// Function to merge Overpass data into CSV data
function mergeData(csvGeoJSON, overpassGeoJSON) {
  const referenceMap = new Map();

  // Add CSV data to the map first
  csvGeoJSON.features.forEach(feature => {
    referenceMap.set(feature.properties.reference, feature);
  });

  // Add Overpass data to the map, overwriting any existing entries with the same reference
  overpassGeoJSON.features.forEach(feature => {
    referenceMap.set(feature.properties.reference, feature);
  });

  return {
    type: "FeatureCollection",
    features: Array.from(referenceMap.values())
  };
}

// Schedule tasks
schedule.scheduleJob('0 * * * *', async () => {
  console.log('Fetching CSV data...');
  const csvData = await fetchCSVData();
  const csvGeoJSON = convertCSVToGeoJSON(csvData);
  cachedGeoJSON = mergeData(csvGeoJSON, cachedGeoJSON);
  console.log('CSV data updated.');
});

schedule.scheduleJob('*/5 * * * *', async () => {
  console.log('Fetching Overpass data...');
  try {
    const overpassData = await fetchOverpassData();
    const overpassGeoJSON = convertOverpassToGeoJSON(overpassData);
    cachedGeoJSON = mergeData(cachedGeoJSON, overpassGeoJSON);
    console.log('Overpass data updated.');

    // Output all elements where the reference begins with "ES-" to spain.json
    const spainGeoJSON = {
      type: "FeatureCollection",
      features: cachedGeoJSON.features.filter(feature => feature.properties.reference && feature.properties.reference.startsWith("ES-"))
    };
    fs.writeFileSync('spain.json', JSON.stringify(spainGeoJSON, null, 2));
    console.log('Filtered data entities written to spain.json');
  } catch (error) {
    console.error('Error fetching or converting Overpass data:', error);
  }
});

// Run tasks on server startup
(async () => {
  console.log('Fetching initial CSV data...');
  const csvData = await fetchCSVData();
  const csvGeoJSON = convertCSVToGeoJSON(csvData);
  cachedGeoJSON = mergeData(csvGeoJSON, cachedGeoJSON);
  console.log('Initial CSV data fetched and cached.');

  console.log('Fetching initial Overpass data...');
  try {
    const overpassData = await fetchOverpassData();
    const overpassGeoJSON = convertOverpassToGeoJSON(overpassData);
    cachedGeoJSON = mergeData(cachedGeoJSON, overpassGeoJSON);
    console.log('Initial Overpass data fetched and cached.');

    // Output all elements where the reference begins with "ES-" to spain.json
    const spainGeoJSON = {
      type: "FeatureCollection",
      features: cachedGeoJSON.features.filter(feature => feature.properties.reference && feature.properties.reference.startsWith("ES-"))
    };
    fs.writeFileSync('spain.json', JSON.stringify(spainGeoJSON, null, 2));
    console.log('Filtered data entities written to spain.json');
  } catch (error) {
    console.error('Error fetching or converting initial Overpass data:', error);
  }
})();

// Endpoint to get cached GeoJSON data with bounding box
app.get('/geojson', (req, res) => {
  const { bbox } = parse(req.url, true).query;
  if (!bbox) {
    return res.status(400).send('Bounding box (bbox) query parameter is required.');
  }

  const [minLon, minLat, maxLon, maxLat] = bbox.split(',').map(Number);
  const filteredFeatures = cachedGeoJSON.features.filter(feature => {
    const [lon, lat] = feature.geometry.coordinates;
    return lon >= minLon && lon <= maxLon && lat >= minLat && lat <= maxLat;
  });

  res.json({
    type: "FeatureCollection",
    features: filteredFeatures
  });
});

app.listen(port, () => {
  console.log(`Server is running on http://localhost:${port}`);
});
